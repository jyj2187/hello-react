# 리액트 시작
## 왜 리액트인가?
- 자바스크립트 만으로도 규모가 큰 애플리케이션을 만들 수 있는 시대
- 기존의 자바스크립트 기반 프레임워크들은 뷰의 특정 요소를 변형시키는 데에 복잡도와 성능 면에서 이슈가 있었다. (현재는 많이 해결됐을듯?!)
- 페이스북 개발팀의 해결 방식 => 요소가 변경될 때마다 뷰를 날려버리고 다시 렌더링하자!
- 코드의 양도 줄고, 복잡하지도 않고, 정해진 규칙에 따라 뷰만 신경쓰면 된다.

### 리액트 이해
- 리액트는 자바스크립트 라이브러리(프레임워크 아님!)로 오직 View만 신경 쓴다.
- 특정 부분이 어떻게 생길지 정하는 선언체 : **컴포넌트**
    - 컴포넌트는 재사용이 가능한 API로 많은 기능들을 내장하고 있으며, 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의한다.
- **렌더링** : 사용자 화면에 뷰를 보여주는 것
- 어떻게 뷰의 데이터가 변할 때마다 새롭게 리렌더링하면서 성능을 아끼고, 최적의 사용자 경험을 제공할 수 있을까?

#### 초기 렌더링
- **render() {...} 함수** : 리액트에서 맨 처음 어떻게 보일지를 정하는 초기 렌더링 함수
    - 이 함수는 컴포넌트가 어떻게 생겼는지 정의하는 역할.
    - html 형식의 문자열을 반환하지 않고, 뷰의 생김새와 작동 정보를 지닌 객체를 반환.
    - 컴포넌트 내부에 또 다른 컴포넌트가 들어갈 수 있다.
    - 이 때, 내부에 있는 컴포넌트들도 재귀적으로 렌더링
- 최상위 컴포넌트의 렌더링 작업이 끝나면, 지니고 있는 정보들을 사용하여 HTML 마크업을 만들고, 실제 페이지의 DOM 요소 안에 주입한다.

#### 조화 과정
- **조화 과정**을 거친다 : 뷰의 업데이트 과정을 거친다.
- 뷰가 변형되는 것이 아닌, 새로운 요소로 갈아끼우는 과정이기 때문.
- 이 과정에서 render 함수가 재호출된다.
- render 함수의 반환 결과를 곧바로 DOM에 반영하지 않고, 이전 render 함수가 만들었던 컴포넌트 정보와 현재 만들어진 컴포넌트 정보를 비교한다.
- 두 가지 뷰를 최소한의 연산으로 비교한 후, 둘의 차이를 최소한의 연산으로 DOM 트리에 업데이트.
- 루트 노드부터 전체 컴포넌트를 다시 렌더링하는 것처럼 보이지만, 최석의 자원을 사용하여 이를 수행.

## 리액트의 특징