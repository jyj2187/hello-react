## 많은 데이터 렌더링하기

- useState 기본값에 함수를 넣어주면 컴포넌트가 처음 렌더링될 때만 함수가 실행된다. (더미 데이터 만들 때 사용)

## 크롬 개발자 도구를 통한 성능 모니터링

- React Devtools를 사용하여 측정 (Chrome 확장 프로그램)
- Profiler 탭에서 파란색 녹화 버튼으로 성능 측정
- 변화를 일으킨 컴포넌트랑 관계 없는 컴포넌트들도 리렌더링된 것을 확인할 수 있다.

## 느려지는 원인 분석

- 부모 컴포넌트가 리렌더링되면 자식 컴포넌트와 그 안의 무수한 컴포넌트들도 같이 리렌더링된다.
- 리렌더링이 불필요할 때는 리렌더링을 방지해 주어야 한다.

## React.memo를 통한 컴포넌트 리렌더링 성능 최적화

- shouldComponentUpdate 라이프 사이클을 사용한다.
- 함수 컴포넌트에서는 쓰지 못하는걸?
- 그럼 React.memo라는 함수가 있다!
- 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정할 수 있다.
- React.memo의 사용법은 컴포넌트를 만들고 감싸 주기만 하면 된다.
- 하지만 React.memo로는 최적화가 끝나지 않는다.

## onToggle과 onRemove가 새로워지는 현상 방지

- 현재 Todo 프로젝트에서는 todos 배열이 업데이트되면 onRemove와 onToggle 함수도 새롭게 바뀐다.
- 배열 상태를 업데이트하는 과정에서 최신 상태의 todos를 참조하기 때문에 배열이 바뀔때마다 함수가 새로 만들어진다.
- 함수가 계속 만들어지는 상황을 방지하는 방법은 두가지이다.

  1. useState의 함수형 업데이트 기능 사용

  - setTodos를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수 있다.
  - ex)

  ```javascript
  const [number, setNumber] = useState(0);

  const onIncrease = useCallback(
    () => setNumber((prevNumber) => prevNumber + 1),
    [],
  );
  ```

  - setNumber(number + 1) 대신에 어떻게 업데이트 할지 정의해주는 업데이트 함수를 넣어준다.
  - 그럼 두번째 파라미터로 넣는 배열에 number를 넣지 않아도 된다.

  2. useReducer 사용

  - useReducer를 사용할 때는 원래 두 번째 파라미터에 초기 상태를 넣어주어야 한다.
  - 지금은 그 대신 undefined를 넣고, 세번째 파라미터에 초기상태를 만들어주는 함수를 넣어준다.
  - 컴포넌트가 맨 처음 렌더링될 때만 함수가 호출된다.
  - 기존 코드를 많이 고쳐야 한다는 단점이 있지만,
  - 상태를 업데이트하는 로직을 모아서 컴포넌트 바깥에 둘 수 있다는 장점이 있다.

- 성능상으로는 두가지 방법이 비슷하다.

## 불변성의 중요성

- 컴포넌트의 상태를 업데이트할 때 불변성을 지키는 것은 매우 중요하다.
- 기존 데이터를 직접 수정하지 않고, 새로운 배열을 만든 다음에 새로운 객체를 만들어서 필요한 부분을 교체해주는 방식으로 구현
- React.memo를 사용했을 때, props가 바뀌었는지 알아내서 리렌더링 성능을 최적화해줄 수 있다.
- 이처럼 기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 "불변성을 지킨다"고 한다.
- 불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못한다.
  > React.memo를 사용한 최적화가 불가능해진다.
- 전개 연산자 (...)를 사용하여 객체나 배열 내부의 값을 복사할 때는 얕은 복사를 하게 된다.
  > 완전히 새로 복사되는 것이 아니라 가장 바깥쪽에 있는 값만 복사된다.
- 만약 객체 안에 있는 객체라면 불변성을 지키기 위해서는 객체 안에 있는 객체까지 얕은 복사를 해야 한다.

```javascript
const nextComplexObject = {
  ...complexObject,
  objectInside: {
    ...complexObject.objectInside,
    enables: false,
  },
};
```

- 배열 혹은 객체의 구조가 복잡해진다면 immer라는 라이브러리의 도움을 받아서 편하게 작업할 수 있다.

## TodoList 컴포넌트 최적화

- 리스트에 관련된 컴포넌트를 최적화할 때는 리스트 내부에서 사용하는 컴포넌트도 최적화해야 한다.
- 리스트로 사용되는 컴포넌트 그 자체도 최적화해야 한다.
- 당장 TodoList는 todos 배열의 업데이트에만 리렌더링되므로 최적화할 시 성능에 영향이 가지 않는다.
- 하지만 최상위 컴포넌트에 다른 state가 추가되어 해당 값들이 업데이트될 때는 TodoList 컴포넌트가 불필요한 리렌더링을 할 수 있다.
- 리스트 관련 컴포넌트를 작성할 때는 리스트 아이템과 리스트, 두가지 컴포넌트를 최적화해주어야 한다.
  > 내부 데이터가 100개를 넘지 않거나, 업데이트가 자주 발생하지 않는다면 반드시 해줄 필요는 없다. 하지만 하면 좋다. 아니 최적화는 무적권 좋다. 무적권이기 때문이다.

## react-virtualized를 사용한 렌더링 최적화

- 리스트 컴포넌트에서 스크롤되기 전에 보이지 않는 컴포넌트는 렌더링하지 않고 크기만 차지하게끔 할 수 있다.
- 스크롤되면 해당 스크롤 위치에서 보여 주어야 할 컴포넌트를 자연스럽게 렌더링시킨다.
- 사전작업: 각 항목의 실제 크기를 px 단위로 알아낸다.
- 

## 정리
- 리액트 컴포넌트의 렌더링은 기본적으로 빠르기 때문에 컴포넌트를 개발할 때 최적화 작업에 스트레스 받을 필요는 없다.
- 단, 리스트와 관련된 컴포넌트를 만들 때 보여 줄 항목이 많거나, 업데이트가 자주 발생한다면 최적화는 필요하다.