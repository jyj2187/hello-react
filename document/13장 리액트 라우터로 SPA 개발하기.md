## SPA란?

- Single Page Application의 약어
- 뷰 렌더링을 사용자의 브라우저가 담당
- 사용자와의 인터랙션이 발생하면 필요한 부분만 자바스크립트를 사용하여 업데이트해 준다.
- 새로운 데이터가 필요하다면 서버 API를 호출하여 필요한 데이터만 새로 불러와 애플리케이션에서 사용할 수도 있다.
- 서버에서 사용자에게 제공하는 페이지는 한 종류
- 하지만 해당 페이지에서 로딩된 자바스크립트와 현재 사용자 브라우저의 주소 상태에 따라 다양한 화면을 보여줄 수 있다.
- 다른 주소에 다른 화면을 보여주는 것을 **라우팅**이라고 한다.
- 리액트 라우팅 라이브러리는 리액트 라우터, 리치 라우터, Next.js등 여러가지가 있다.
- 리액트 라우터는 클라이언트 사이드에서 이루어지는 라우팅을 아주 간단하게 구현할 수 있도록 해준다.

- **SPA의 단점**
  - 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다.
    > 사용자가 실제로 방문하지 않을 페이지의 스크립트도 불러오기 때문  
    > 코드 스플리팅으로 라우트 별로 파일들을 나누면 트래픽과 로딩 속도를 개선할 수 있다.
  - 자바스크립트가 실행되기 전까지는 페이지가 비어 있기 때문에 검색 엔진에 노출이 되지 않을 가능성이 있다.
    > 서버 사이드 렌더링으로 해결 가능

## react-router-dom 적용

- index.js의 root.render 안 최상위 컴포넌트를 `<BrowserRouter>` 로 감싸면 된다.
  > 리액트 라우터에서는 여러가지의 라우터 컴포넌트를 지원한다.  
  > 그 중 가장 쓰이는 빈도가 높은 것이 BrowserRouter와 HashRouter이다.
  - BrowserRouter: 브라우저의 주소를 받아 라우팅
  - HashRouter: 해시 값도 주소로 받아 라우팅
- App(메인 컴포넌트)에서 `<Route path="/주소" element={<컴포넌트 />}>` 로 작성.
- **Route 컴포넌트를 Routes 컴포넌트로 감싼다!** : react-router-dom v6부터 적용
- v6부터는 exact={true}가 기본값이라서 따로 설정해주지 않아도 된다.
- v6부터는 한 컴포넌트에 여러 주소를 매핑하려면 Route 컴포넌트를 하나 더 만들거나, useRoute를 최상위 컴포넌트의 Router 단에서 선언해주어야 한다.
  > path 파라미터의 배열 사용이 막힘.
- `<Link to="주소">내용</Link>` 컴포넌트를 사용해서 라우팅 링크를 집어넣을 수 있다.
  - 리액트 라우터를 사용할 때는 a 태그를 사용하면 애플리케이션이 들고 있던 상태들을 모두 날려버리게 된다.
  - Link 컴포넌트를 사용하면, 애플리케이션의 상태는 유지한 채 HTML5 History API를 사용하여 페이지의 주소만 변경해준다.
  - a 태그로 이루어져 있지만, 페이지의 전환을 방지하는 기능이 내장되어 있다.

## URL 파라미터와 쿼리

- 파라미터 : /profile/**jyj2187**
- 쿼리 : /about?**details=true**
- 페이지 주소에서 유동적인 값
- 일반적으로 파라미터는 조회용, 쿼리는 검색 혹은 페이지 옵션을 전달할 때 사용
- v6 부터는 match를 props로 넣어주거나, :파라미터를 라우팅된 컴포넌트 안에서 useParams() 받아올 수 있다.
- 쿼리의 경우, location 객체를 useLocation() 함수로 받아올 수 있다.
  - pathname: 현재 주소의 경로 (쿼리스트링 제외)
  - search: 맨 앞의 ? 문자 포함한 쿼리스트링 값
  - hash: 주소의 # 문자열 뒤의 값 (주로 History API 가 지원되지 않는 구형 브라우저에서 클라이언트 라우팅을 사용할 때 쓰는 해시 라우터에서 사용합니다.)
  - state: 페이지로 이동할때 임의로 넣을 수 있는 상태 값
  - key: location 객체의 고유 값, 초기에는 default 이며 페이지가 변경될때마다 고유의 값이 생성됨
- 쿼리는 주소의 "?"부터 시작하는 부분으로 "&"을 써서 각 쿼리를 구분할 수 있다.
- location.search로 가져온 쿼리 스트링의 경우 문자열이기 때문에 파싱해야하지만, npm에서 제공하는 qs, 쿼리스트링 라이브러리로 간편하게 처리할 수 있다.
- 덧붙여 리액트 라우터 v6에서는 useSearchParams() 함수를 이용해서 쿼리 스트링을 쉽게 받아올 수 있다.

## 중첩된 라우팅

- Outlet 컴포넌트는 Route의 children 으로 들어가는 JSX 엘리먼트를 보여주는 역할을 한다.
