## SPA란?

- Single Page Application의 약어
- 뷰 렌더링을 사용자의 브라우저가 담당
- 사용자와의 인터랙션이 발생하면 필요한 부분만 자바스크립트를 사용하여 업데이트해 준다.
- 새로운 데이터가 필요하다면 서버 API를 호출하여 필요한 데이터만 새로 불러와 애플리케이션에서 사용할 수도 있다.
- 서버에서 사용자에게 제공하는 페이지는 한 종류
- 하지만 해당 페이지에서 로딩된 자바스크립트와 현재 사용자 브라우저의 주소 상태에 따라 다양한 화면을 보여줄 수 있다.
- 다른 주소에 다른 화면을 보여주는 것을 **라우팅**이라고 한다.
- 리액트 라우팅 라이브러리는 리액트 라우터, 리치 라우터, Next.js등 여러가지가 있다.
- 리액트 라우터는 클라이언트 사이드에서 이루어지는 라우팅을 아주 간단하게 구현할 수 있도록 해준다.

- **SPA의 단점**
  - 앱의 규모가 커지면 자바스크립트 파일이 너무 커진다.
    > 사용자가 실제로 방문하지 않을 페이지의 스크립트도 불러오기 때문  
    > 코드 스플리팅으로 라우트 별로 파일들을 나누면 트래픽과 로딩 속도를 개선할 수 있다.
  - 자바스크립트가 실행되기 전까지는 페이지가 비어 있기 때문에 검색 엔진에 노출이 되지 않을 가능성이 있다.
    > 서버 사이드 렌더링으로 해결 가능

## react-router-dom 적용

- index.js의 root.render 안 최상위 컴포넌트를 `<BrowserRouter>` 로 감싸면 된다.
  > 리액트 라우터에서는 여러가지의 라우터 컴포넌트를 지원한다.  
  > 그 중 가장 쓰이는 빈도가 높은 것이 BrowserRouter와 HashRouter이다.
  - BrowserRouter: 브라우저의 주소를 받아 라우팅
  - HashRouter: 해시 값도 주소로 받아 라우팅
- App(메인 컴포넌트)에서 `<Route path="/주소" element={<컴포넌트 />}>` 로 작성.
- **Route 컴포넌트를 Routes 컴포넌트로 감싼다!** : react-router-dom v6부터 적용
- v6부터는 exact={true}가 기본값이라서 따로 설정해주지 않아도 된다.
- v6부터는 한 컴포넌트에 여러 주소를 매핑하려면 Route 컴포넌트를 하나 더 만들거나, useRoute를 최상위 컴포넌트의 Router 단에서 선언해주어야 한다.
  > path 파라미터의 배열 사용이 막힘.
- `<Link to="주소">내용</Link>` 컴포넌트를 사용해서 라우팅 링크를 집어넣을 수 있다.
  - 리액트 라우터를 사용할 때는 a 태그를 사용하면 애플리케이션이 들고 있던 상태들을 모두 날려버리게 된다.
  - Link 컴포넌트를 사용하면, 애플리케이션의 상태는 유지한 채 HTML5 History API를 사용하여 페이지의 주소만 변경해준다.
  - a 태그로 이루어져 있지만, 페이지의 전환을 방지하는 기능이 내장되어 있다.

## URL 파라미터와 쿼리

- 파라미터 : /profile/**jyj2187**
- 쿼리 : /about?**details=true**
- 페이지 주소에서 유동적인 값
- 일반적으로 파라미터는 조회용, 쿼리는 검색 혹은 페이지 옵션을 전달할 때 사용
- v6 부터는 match를 props로 넣어주거나, :파라미터를 라우팅된 컴포넌트 안에서 useParams() 받아올 수 있다.
- 쿼리의 경우, location 객체를 useLocation() 함수로 받아올 수 있다.
  - pathname: 현재 주소의 경로 (쿼리스트링 제외)
  - search: 맨 앞의 ? 문자 포함한 쿼리스트링 값
  - hash: 주소의 # 문자열 뒤의 값 (주로 History API 가 지원되지 않는 구형 브라우저에서 클라이언트 라우팅을 사용할 때 쓰는 해시 라우터에서 사용합니다.)
  - state: 페이지로 이동할때 임의로 넣을 수 있는 상태 값
  - key: location 객체의 고유 값, 초기에는 default 이며 페이지가 변경될때마다 고유의 값이 생성됨
- 쿼리는 주소의 "?"부터 시작하는 부분으로 "&"을 써서 각 쿼리를 구분할 수 있다.
- location.search로 가져온 쿼리 스트링의 경우 문자열이기 때문에 파싱해야하지만, npm에서 제공하는 qs, 쿼리스트링 라이브러리로 간편하게 처리할 수 있다.
- 덧붙여 리액트 라우터 v6에서는 useSearchParams() 함수를 이용해서 쿼리 스트링을 쉽게 받아올 수 있다.

## 중첩된 라우팅

- 게시글 목록 페이지에서 게시글을 열었을 때, 게시글 하단에 목록을 보여줘야 한다면 어떻게 해야할까?
- 기존 방식대로 한다면 게시글 목록에 대한 컴포넌트를 새로 만들어야 했을 것이다.
- Outlet 컴포넌트는 Route의 children 으로 들어가는 JSX 엘리먼트를 보여주는 역할을 한다.
- 페이지끼리 공통적으로 보여줘야 하는 레이아웃이 있을때도 유용하게 사용할 수 있다.
- index props는 path="/" 와 같은 기능을 한다.

## 리액트 라우터 부가기능

1. useNavigate Hook

- useNavigate는 Link 컴포넌트를 사용하지 않고 다른 페이지로 이동을 해야하는 상황에 사용하는 Hook이다.
- navigate의 파라미터가 숫자 타입이라면 앞으로 가거나 뒤로 간다.
  > ex) navigate(-1) 뒤로가기  
  > navigate(1) 앞으로 가기  
  > navigate(-2) 뒤로 두번 가기
- 파라미터를 문자열로 주소를 직접 넣을 수도 있다.
- 두번째 파라미터로 { replace: true } 옵견을 설정해주면 페이지를 이동할 때 현재 페이지를 기록에 남기지 않는다.
  - ex) 홈에서 소개 페이지로 이동 후 게시글 목록으로 가기 버튼을 누른 다음에 뒤로 가기 하면
    게시글 목록 페이지는 기록이 되지 않았기 때문에 -1을 할 때 홈 페이지로 돌아가게 된다.

2. NavLink 컴포넌트

- NavLink는 링크에서 사용하는 경로가 현재 라우트의 경로와 일치하는 경우 특정 스타일 또는 CSS 클래스를 적용하는 컴포넌트.
- 이 컴포넌트는 style 또는 className을 설정할 때 { isActive: boolean }을 파라미터로 전달받는 함수 타입의 값을 전달한다.

3. NotFound 페이지 만들기

- 사전에 정의되지 않는 경로에 사용자가 진입했을 때 보여주는 페이지.
- 찾을 수 없는 페이지입니다.
- Route path에 와일드카드를 사용하면 Route를 설정한 경로가 아닌 모든 경로가 해당이 된다.

4. Navigate 컴포넌트

- 컴포넌트를 화면에 보여주는 순간 다른 페이지로 이동을 하고 싶을 때 사용하는 컴포넌트.
- 페이지를 리다이렉트하고 싶을 때 사용한다.
